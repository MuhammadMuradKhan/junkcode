/*
 * $Id: heap9.c,v 1.1 2004/06/19 12:35:29 raptor Exp $
 *
 * heap9.c - classical double-free() vulnerability example
 * Copyright (c) 2004 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * See "Exploit for CVS double free() for Linux pserver" by Igor Dobrovitski
 * (http://seclists.org/lists/fulldisclosure/2003/Feb/0036.html) and the
 * small program (http://0xbadc0ded.org/projects/dl-cat.c) by Joel Eriksson.
 *
 * This vulnerable program will normally segfault, but nevertheless it's
 * useful to understand how double-free() exploitation takes place. 
 *
 * After our vulnerable chunk is allocated (we're sure it comes from the top
 * memory chunk, since it's the first allocated chunk), we malloc() another
 * chunk of some size (8) -- this to make sure our vulnerable chunk will not
 * be coalesced with nearby chunks. After the vulnerable chunk is free()'d
 * twice, if we ask for a chunk of the same size that was double-free()'d we
 * get the very same double-free()'d chunk without actually taking it off its
 * double linked list.
 *
 * Now, manipulating the fd and bk fields of this new chunk (located in its 
 * first 8 bytes) we are able to overwrite an arbitrary memory address upon
 * the next malloc() call (beware to the size!).
 */

#include <signal.h>

void sigsegvhandler()
{
	exit(1);
}

int main(int argc, char **argv)
{
	char *p;

	signal(SIGSEGV, sigsegvhandler);

	p = (char *)malloc(strlen(argv[1]) + 1);
	malloc(8);

	free(p);
	free(p); /* dumb double-free() example */

	p = (char *)malloc(strlen(argv[1]) + 1);
	strcpy(p, argv[1]);

	malloc(strlen(argv[1]) + 1);

	printf("No SIGSEGV\n");

	return(0);
}
